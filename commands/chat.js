import { InteractionResponseType } from 'discord-interactions';
import { DiscordRequest } from '../utils.js';
import { Mistral } from '@mistralai/mistralai';
import { getConversationId, setConversationId } from '../utils/conversationStore.js';
import { getOmniAgentId } from '../utils/agentManager.js';

const client = new Mistral({ apiKey: process.env.MISTRAL_API_KEY });

export const data = {
    name: 'chat',
    description: 'Chat with Mistral AI (shared context)',
    options: [
        {
            type: 3, // STRING
            name: 'message',
            description: 'The message to send',
            required: true,
        }
    ],
    type: 1, // CHAT_INPUT
    integration_types: [0, 1],
    contexts: [0, 1, 2],
};

export async function execute(req, res) {
    const { data, token, application_id, channel_id, member, user } = req.body;
    // Use channel_id for context. If DM, channel_id works fine too.
    const contextId = channel_id;

    // User message
    const userMessage = data.options.find(opt => opt.name === 'message').value;
    const authorUsername = member ? member.user.username : user.username;

    // We defer first
    await res.send({
        type: 5, // DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE
    });

    try {
        let conversationId = getConversationId(contextId);
        console.log(`[DEBUG] Channel: ${contextId}, Found ConvID: ${conversationId}`);

        // Helper function
        const processOutputs = async (outputs) => {
            const payloads = []; // Array of { content: string, embeds: [] }
            let currentText = "";
            let currentEmbeds = [];

            // Helper to flush current buffer
            const flush = () => {
                if (currentText.trim() || currentEmbeds.length > 0) {
                    payloads.push({ content: currentText, embeds: [...currentEmbeds] });
                    currentText = "";
                    currentEmbeds = [];
                }
            }

            if (outputs && outputs.length > 0) {
                const lastOutput = outputs[outputs.length - 1];
                if (lastOutput.type === 'message.output' || lastOutput.role === 'assistant') {
                    if (Array.isArray(lastOutput.content)) {
                        for (const part of lastOutput.content) {
                            if (part.type === 'text') {
                                currentText += part.text;
                            } else if (part.type === 'image_url') {
                                currentEmbeds.push({ image: { url: part.image_url.url } });
                                flush(); // Interleave: flush text + this image
                            } else if (part.type === 'tool_file') {
                                try {
                                    // Mistral SDK expects camelCase 'fileId'
                                    const urlResponse = await client.files.getSignedUrl({ fileId: part.fileId });
                                    if (urlResponse && urlResponse.url) {
                                        currentEmbeds.push({
                                            image: { url: urlResponse.url },
                                            footer: { text: "Generated by Mistral OmniBot" }
                                        });
                                        flush(); // Interleave: flush text + this image
                                    } else {
                                        currentText += `\n[Image generated but URL could not be retrieved: ${part.fileName}]`;
                                    }
                                } catch (err) {
                                    console.error("Error getting signed url:", err);
                                    currentText += `\n[Error retrieving image: ${part.fileName}]`;
                                }
                            }
                        }
                    } else {
                        currentText = lastOutput.content;
                    }
                }
            }

            // Flush remaining text
            flush();
            return payloads;
        };


        if (!conversationId) {
            // Start new conversation
            const agentId = await getOmniAgentId();
            const startParams = {
                agentId: agentId,
                inputs: [{ role: 'user', content: `${authorUsername}: ${userMessage}` }]
            };

            const convoResponse = await client.beta.conversations.start(startParams);

            // API returns conversationId (not id)
            conversationId = convoResponse.conversationId || convoResponse.id;
            setConversationId(contextId, conversationId);

            const startPayloads = await processOutputs(convoResponse.outputs);

            if (startPayloads.length === 0) {
                // Fallback
                startPayloads.push({ content: "I'm not sure how to respond to that." });
            }

            // Send first payload as PATCH (edit original deferred)
            // Send rest as POST (follow-up)
            await sendPayloads(application_id, token, startPayloads);

        } else {
            // Append
            const convoResponse = await client.beta.conversations.append({
                conversationId: conversationId,
                conversationAppendRequest: {
                    inputs: [{ role: 'user', content: `${authorUsername}: ${userMessage}` }]
                }
            });

            const appendPayloads = await processOutputs(convoResponse.outputs);
            if (appendPayloads.length === 0) {
                appendPayloads.push({ content: "I'm not sure how to respond." });
            }

            await sendPayloads(application_id, token, appendPayloads);
        }

    } catch (error) {
        console.error('Error in chat:', error);
        if (error.message && error.message.includes("404")) {
            deleteConversationId(contextId);
        }

        const endpoint = `webhooks/${application_id}/${token}/messages/@original`;
        await DiscordRequest(endpoint, {
            method: 'PATCH',
            body: {
                content: `Sorry, I met an error. (Conversation might be reset). Error: ${error.message}`,
            },
        });
    }
}

// Helper to send interleaved messages
async function sendPayloads(appId, token, payloads) {
    // 1. Edit original message with first payload
    if (payloads.length > 0) {
        const first = payloads[0];
        const endpoint = `webhooks/${appId}/${token}/messages/@original`;
        await DiscordRequest(endpoint, {
            method: 'PATCH',
            body: {
                content: first.content,
                embeds: first.embeds && first.embeds.length > 0 ? first.embeds : undefined,
            },
        });
    }

    // 2. Send follow-ups
    for (let i = 1; i < payloads.length; i++) {
        const payload = payloads[i];
        // POST /webhooks/{application_id}/{interaction_token}
        const endpoint = `webhooks/${appId}/${token}`;
        await DiscordRequest(endpoint, {
            method: 'POST',
            body: {
                content: payload.content,
                embeds: payload.embeds && payload.embeds.length > 0 ? payload.embeds : undefined,
            },
        });
    }
}
